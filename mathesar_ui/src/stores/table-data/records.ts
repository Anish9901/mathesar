import { execPipe, first, map, zip } from 'iter-tools';
import {
  type Readable,
  type Unsubscriber,
  type Writable,
  derived,
  get,
  writable,
} from 'svelte/store';
import { _ } from 'svelte-i18n';

import { States } from '@mathesar/api/rest/utils/requestUtils';
import { api } from '@mathesar/api/rpc';
import type { RawColumnWithMetadata } from '@mathesar/api/rpc/columns';
import type {
  Result as ApiRecord,
  FileManifest,
  RecordsListParams,
  RecordsResponse,
  RecordsSearchParams,
  ResultValue,
} from '@mathesar/api/rpc/records';
import { makeCellId, parseCellId } from '@mathesar/components/sheet/cellIds';
import type { Database } from '@mathesar/models/Database';
import type { Table } from '@mathesar/models/Table';
import {
  RpcError,
  type RpcResponse,
  batchSend,
} from '@mathesar/packages/json-rpc-client-builder';
import type Pagination from '@mathesar/utils/Pagination';
import {
  type CancellablePromise,
  ImmutableMap,
  WritableMap,
  defined,
} from '@mathesar-component-library';

import AssociatedCellData, {
  buildAssociatedCellValuesForSheet,
  mergeAssociatedValuesForSheet,
} from '../AssociatedCellData';

import type { ColumnsDataStore } from './columns';
import type { Filtering } from './filtering';
import type { Grouping as GroupingRequest } from './grouping';
import type { Joining } from './joining';
import type { Meta } from './meta';
import {
  DraftRecordRow,
  PersistedRecordRow,
  type RecordRow,
  type Row,
  isDraftRecordRow,
  isPersistedRecordRow,
} from './Row';
import type { SearchFuzzy } from './searchFuzzy';
import type { Sorting } from './sorting';
import {
  type RecordGrouping,
  type RowKey,
  buildGrouping,
  getCellKey,
  getRowSelectionId,
  validateRow,
} from './utils';

export interface RecordsRequestParamsData {
  pagination: Pagination;
  sorting: Sorting;
  grouping: GroupingRequest;
  filtering: Filtering;
  searchFuzzy: SearchFuzzy;
  joining: Joining;
}

export interface TableRecordsData {
  state: States;
  error?: string;
  rows: Row[];
  totalCount: number;
  grouping?: RecordGrouping;
}

/**
 * A recipe to set the value of one cell
 */
export interface NewCellValueRecipe {
  columnId: string;
  value: unknown;
}

function buildRecordFromRecipe(
  recipe: NewCellValueRecipe[],
): Record<string, ResultValue> {
  return Object.fromEntries(
    recipe.map((cell) => [cell.columnId, cell.value as ResultValue]),
  );
}

/**
 * A recipe to modify one existing row in the sheet.
 *
 * Note that this might not be an existing row _in PostgreSQL_ (because in the
 * case of draft record rows, a row can exist in the sheet without yet existing
 * in PostgreSQL.)
 */
export interface RowModificationRecipe {
  row: RecordRow;
  cells: NewCellValueRecipe[];
}

/**
 * @throws Error if the recipe has problems
 */
function validateRowModificationRecipe(
  { row, cells }: RowModificationRecipe,
  pkColumn: RawColumnWithMetadata,
): void {
  // Validate that PK value exists if we're updating a saved row
  const primaryKeyValue = row.record[pkColumn.id];
  if (isPersistedRecordRow(row) && primaryKeyValue === undefined) {
    throw new Error(
      'Unable to update record for a row with a missing primary key value',
    );
  }

  // Validate against problems with directly editing PK values
  const isEditingPk = cells.some((c) => c.columnId === String(pkColumn.id));
  if (isEditingPk) {
    if (!isDraftRecordRow(row)) {
      // If modifying a PK cell in a saved record, then block editing.
      throw new Error('Unable to modify primary key cells of saved rows');
    }
    if (pkColumn.default && pkColumn.default.is_dynamic) {
      // If modifying a PK cell in a _draft_ row, and when the PK column has a
      // dynamic default value set, then block editing. This is because we
      // want the user to stick with the default PK value when creating new
      // records.
      throw new Error(
        'Unable to modify cells in a primary key column with a dynamic default',
      );
    }
    // Otherwise, (if we're modifying a PK cell in a draft row, and the PK
    // column does not have a dynamic default) then we allow editing. This
    // is so that the user can set their own PK values when inserting rows.
  }
}

/** A recipe to add one row to the sheet */
export interface RowAdditionRecipe {
  cells: NewCellValueRecipe[];
}

function makeRowModificationRecipe(
  rowAdditionRecipe: RowAdditionRecipe,
): RowModificationRecipe {
  const record = buildRecordFromRecipe(rowAdditionRecipe.cells);
  const row = new DraftRecordRow({ record });
  return {
    row,
    cells: rowAdditionRecipe.cells,
  };
}

export class RecordsData {
  private apiContext: {
    database_id: number;
    table_oid: Table['oid'];
  };

  private meta: Meta;

  private columnsDataStore: ColumnsDataStore;

  state: Writable<States>;

  fetchedRecordRows: Writable<PersistedRecordRow[]>;

  newRecords: Writable<(PersistedRecordRow | DraftRecordRow)[]>;

  persistedNewRecords: Readable<PersistedRecordRow[]>;

  recordSummaries = new WritableMap<string, string>();

  linkedRecordSummaries = new AssociatedCellData<string>();

  joinedRecordSummaries = new AssociatedCellData<string>();

  fileManifests = new AssociatedCellData<FileManifest>();

  grouping: Writable<RecordGrouping | undefined>;

  totalCount: Writable<number | undefined>;

  error: Writable<string | undefined>;

  /** Keys are row selection ids */
  selectableRowsMap: Readable<Map<string, PersistedRecordRow | DraftRecordRow>>;

  private promise: CancellablePromise<RecordsResponse> | undefined;

  // @ts-ignore: https://github.com/centerofci/mathesar/issues/1055
  private createPromises: Map<unknown, CancellablePromise<unknown>>;

  // @ts-ignore: https://github.com/centerofci/mathesar/issues/1055
  private updatePromises: Map<unknown, CancellablePromise<unknown>>;

  private requestParamsUnsubscriber: Unsubscriber;

  /**
   * This maps column ids (as strings) to cell values. It is used to supply default values
   * for the cells within hidden columns when creating new records.
   */
  private contextualFilters: Map<string, number | string>;

  private loadIntrinsicRecordSummaries?: boolean;

  constructor({
    database,
    table,
    meta,
    columnsDataStore,
    contextualFilters,
    loadIntrinsicRecordSummaries,
  }: {
    database: Pick<Database, 'id'>;
    table: Pick<Table, 'oid'>;
    meta: Meta;
    columnsDataStore: ColumnsDataStore;
    contextualFilters: Map<string, number | string>;
    loadIntrinsicRecordSummaries?: boolean;
  }) {
    this.apiContext = { database_id: database.id, table_oid: table.oid };
    this.state = writable(States.Loading);
    this.fetchedRecordRows = writable([]);
    this.newRecords = writable([]);
    this.grouping = writable(undefined);
    this.totalCount = writable(undefined);
    this.error = writable(undefined);
    this.meta = meta;
    this.columnsDataStore = columnsDataStore;
    this.contextualFilters = contextualFilters;
    this.loadIntrinsicRecordSummaries = loadIntrinsicRecordSummaries;

    void this.fetch();

    this.selectableRowsMap = derived(
      [this.fetchedRecordRows, this.newRecords],
      ([fetchedRecordRows, newRecords]) => {
        const records = [...fetchedRecordRows, ...newRecords];
        return new Map(records.map((r) => [getRowSelectionId(r), r]));
      },
    );

    this.persistedNewRecords = derived(this.newRecords, (newRecords) =>
      newRecords.filter((row): row is PersistedRecordRow =>
        isPersistedRecordRow(row),
      ),
    );

    // TODO: Create base class to abstract subscriptions and unsubscriptions
    this.requestParamsUnsubscriber =
      this.meta.recordsRequestParamsData.subscribe(() => {
        void this.fetch();
      });
  }

  async fetch(
    opts: {
      clearNewRecords?: boolean;
      setLoadingState?: boolean;
      clearMetaStatuses?: boolean;
    } = {},
  ): Promise<void> {
    const options = {
      clearNewRecords: true,
      setLoadingState: true,
      clearMetaStatuses: true,
      ...opts,
    };

    this.promise?.cancel();
    this.error.set(undefined);

    if (options.clearNewRecords) {
      this.newRecords.set([]);
    }
    if (options.setLoadingState) {
      this.state.set(States.Loading);
    }
    if (options.clearMetaStatuses) {
      this.meta.clearAllStatusesAndErrors();
    }

    try {
      const params = get(this.meta.recordsRequestParamsData);

      const recordsListParams: RecordsListParams = {
        ...this.apiContext,
        ...params.pagination.recordsRequestParams(),
        ...params.sorting.recordsRequestParamsIncludingGrouping(
          params.grouping,
        ),
        ...params.grouping.recordsRequestParams(),
        ...params.filtering
          .withContextualFilters(this.contextualFilters)
          .recordsRequestParams(),
        return_record_summaries: this.loadIntrinsicRecordSummaries,
        ...params.joining.recordsRequestParams(),
      };

      const fuzzySearchParams = params.searchFuzzy.getSearchParams();
      const recordSearchParams: RecordsSearchParams = {
        ...this.apiContext,
        ...params.pagination.recordsRequestParams(),
        search_params: fuzzySearchParams,
        return_record_summaries: this.loadIntrinsicRecordSummaries,
      };

      this.promise = fuzzySearchParams.length
        ? api.records.search(recordSearchParams).run()
        : api.records.list(recordsListParams).run();

      const response = await this.promise;
      const totalCount = response.count || 0;
      const grouping = response.grouping
        ? buildGrouping(response.grouping)
        : undefined;
      if (response.linked_record_summaries) {
        this.linkedRecordSummaries.setFetchedValuesFromPrimitive(
          response.linked_record_summaries,
        );
      }
      if (response.joined_record_summaries) {
        this.joinedRecordSummaries.setFetchedValuesFromPrimitive(
          response.joined_record_summaries,
        );
      }
      if (response.record_summaries) {
        this.recordSummaries.reconstruct(
          Object.entries(response.record_summaries),
        );
      }
      if (response.download_links) {
        this.fileManifests.setFetchedValuesFromPrimitive(
          response.download_links,
        );
      }
      this.fetchedRecordRows.set(
        response.results.map(
          (apiRecord) =>
            new PersistedRecordRow({
              record: apiRecord,
            }),
        ),
      );
      this.state.set(States.Done);
      this.grouping.set(grouping);
      this.totalCount.set(totalCount);
      this.error.set(undefined);
    } catch (err) {
      this.state.set(States.Error);
      this.error.set(
        err instanceof Error ? err.message : 'Unable to load records',
      );
    }
    return undefined;
  }

  /** @returns the number of selected rows deleted */
  async deleteSelected(rowSelectionIds: Iterable<string>): Promise<number> {
    const pkColumn = get(this.columnsDataStore.pkColumn);
    if (!pkColumn) throw new Error('Cannot delete without primary key');

    const rowIds =
      typeof rowSelectionIds === 'string' ? [rowSelectionIds] : rowSelectionIds;
    const allSelectableRows = get(this.selectableRowsMap);

    const draftRowsToDelete: Map<string, DraftRecordRow> = new Map();
    const persistedRowsToDelete: Map<string, PersistedRecordRow> = new Map();

    for (const rowId of rowIds) {
      const row = allSelectableRows.get(rowId);
      if (!row) continue;

      if (isDraftRecordRow(row)) {
        draftRowsToDelete.set(row.identifier, row);
      } else {
        persistedRowsToDelete.set(row.identifier, row);
      }
    }

    if (!draftRowsToDelete.size && !persistedRowsToDelete.size) {
      return 0;
    }

    this.meta.rowDeletionStatus.setMultiple(
      [...draftRowsToDelete.keys(), ...persistedRowsToDelete.keys()],
      { state: 'processing' },
    );

    const rowsSuccessfullyDeleted = new Set<RowKey>(draftRowsToDelete.keys());

    /** Values are error messages */
    const rowsFailedToDelete = new Map<RowKey, RpcError>();

    if (persistedRowsToDelete.size) {
      const primaryKeysOfPersistedRows = [
        ...persistedRowsToDelete.values(),
      ].map((row) => row.record[pkColumn.id]);

      try {
        const deletionRequest = api.records
          .delete({
            database_id: this.apiContext.database_id,
            table_oid: this.apiContext.table_oid,
            record_ids: primaryKeysOfPersistedRows,
          })
          .run();
        const deletedIds = new Set(await deletionRequest);
        persistedRowsToDelete.forEach((row) => {
          const rowId = row.record[pkColumn.id];
          if (deletedIds.has(rowId)) {
            rowsSuccessfullyDeleted.add(row.identifier);
          } else {
            // This can happen in the case of a failure due to RLS
            const msg = get(_)('row_deletion_ignored_by_pg', {
              values: { rowId: String(rowId) },
            });
            rowsFailedToDelete.set(row.identifier, RpcError.fromAnything(msg));
          }
        });
      } catch (error) {
        persistedRowsToDelete.forEach((row) =>
          rowsFailedToDelete.set(row.identifier, RpcError.fromAnything(error)),
        );
      }
    }
    const shouldReFetchRecords = rowsSuccessfullyDeleted.size > 0;

    // We clear all records from the new records section because we expect that
    // those records will be re-fetched and end up in the main table area. This
    // expectation doesn't always hold though. Sometimes the new record section
    // contains records that haven't yet been saved (e.g. when a record has a
    // NOT NULL constraint). In that case we delete the unsaved records anyway,
    // just because that's simpler. We have some opportunity for UX improvement
    // here, and we should discuss the subtleties of our desired behavior when
    // deleting records.
    this.newRecords.set([]);

    // It's important that we update `newRecords` before we re-fetch, otherwise
    // we could end up with duplicate records that cause JS errors due to
    // svelte's keyed each block. Duplicates can occur if the user creates two
    // records and then deletes one of them, leaving a new records in the
    // `newRecords` array that also gets re-fetched. It's also important that we
    // update `newRecords` regardless of wether we had any _saved_ records to
    // delete, because sometimes the user is just deleting an unsaved record.
    // These reasons together are why we're using this `shouldReFetchRecords`
    // flag instead of just re-fetching the records immediately after deleting
    // the saved records.
    if (shouldReFetchRecords) {
      await this.fetch({
        clearMetaStatuses: false,
        clearNewRecords: false,
        setLoadingState: false,
      });
    }

    this.meta.rowCreationStatus.delete(
      Array.from(rowsSuccessfullyDeleted, String),
    );
    this.meta.clearAllStatusesAndErrorsForRows([...rowsSuccessfullyDeleted]);
    this.meta.rowDeletionStatus.setEntries(
      [...rowsFailedToDelete.entries()].map(([rowKey, error]) => [
        rowKey,
        { state: 'failure', errors: [error] },
      ]),
    );
    this.meta.rowDeletionStatus.clear();

    if (rowsFailedToDelete.size > 0) {
      const uiMsg = get(_)('unable_to_delete_count_rows', {
        values: { count: rowsFailedToDelete.size },
      });
      const apiMsg = [...rowsFailedToDelete.values()].join('\n');
      throw new Error(`${uiMsg} ${apiMsg}`);
    }

    return draftRowsToDelete.size + persistedRowsToDelete.size;
  }

  /**
   * @throws Error if PK column does not exist
   */
  private getPkColumOrError() {
    const pkColumn = get(this.columnsDataStore.pkColumn);
    if (!pkColumn) throw new Error('Unable to update without primary key');
    return pkColumn;
  }

  private updateSummaryStores(responses: RpcResponse<RecordsResponse>[]): void {
    let newLinkedRecordSummaries: ImmutableMap<
      string,
      ImmutableMap<string, string>
    > = new ImmutableMap();
    let newJoinedRecordSummaries: ImmutableMap<
      string,
      ImmutableMap<string, string>
    > = new ImmutableMap();
    for (const response of responses) {
      if (response.status === 'error') continue;
      const linkedRecordSummaries = response.value.linked_record_summaries;
      if (linkedRecordSummaries) {
        newLinkedRecordSummaries = mergeAssociatedValuesForSheet(
          newLinkedRecordSummaries,
          buildAssociatedCellValuesForSheet(linkedRecordSummaries),
        );
      }
      const joinedRecordSummaries = response.value.joined_record_summaries;
      if (joinedRecordSummaries) {
        newJoinedRecordSummaries = mergeAssociatedValuesForSheet(
          newJoinedRecordSummaries,
          buildAssociatedCellValuesForSheet(joinedRecordSummaries),
        );
      }
    }
    this.linkedRecordSummaries.addBespokeValues(newLinkedRecordSummaries);
    this.joinedRecordSummaries.addBespokeValues(newJoinedRecordSummaries);
  }

  async bulkDml({
    modificationRecipes,
    additionRecipes,
  }: {
    modificationRecipes: RowModificationRecipe[];
    additionRecipes: RowAdditionRecipe[];
  }): Promise<{ rowIds: string[]; columnIds: string[] }> {
    const convertedRecipes = additionRecipes.map(makeRowModificationRecipe);
    const additionalRows = convertedRecipes
      .map(({ row }) => row)
      .filter(isDraftRecordRow);

    const pkColumn = this.getPkColumOrError();
    const unifiedRecipes = [...modificationRecipes, ...convertedRecipes];
    unifiedRecipes.forEach((r) => validateRowModificationRecipe(r, pkColumn));

    this.newRecords.update((rows) => [...rows, ...additionalRows]);

    await this.bulkUpdate(unifiedRecipes, { validateRecipes: false });
    return {
      rowIds: unifiedRecipes.map((recipe) => recipe.row.identifier),
      columnIds:
        defined(unifiedRecipes.at(0), (r) => r.cells.map((c) => c.columnId)) ??
        [],
    };
  }

  async bulkUpdate(
    recipes: RowModificationRecipe[],
    options: {
      /**
       * When true, the recipes will be checked for errors. True by default.
       */
      validateRecipes?: boolean;
    } = {},
  ): Promise<void> {
    const defaultOptions = { validateRecipes: true };
    const { validateRecipes } = { ...defaultOptions, ...options };

    const cellStatus = this.meta.cellModificationStatus;
    const { cellClientSideErrors, rowCreationStatus } = this.meta;
    const pkColumn = this.getPkColumOrError();

    const recipeMap = new Map(
      recipes.map((recipe) => [recipe.row.identifier, recipe]),
    );

    function preProcessRecordRow<R extends RecordRow>(row: R): R {
      const recipe = recipeMap.get(row.identifier);
      if (!recipe) return row;
      return row.withRecord({
        ...row.record,
        ...buildRecordFromRecipe(recipe.cells),
      }) as R;
    }

    // Optimistic UI updates prior to API calls
    this.fetchedRecordRows.update((rows) => rows.map(preProcessRecordRow));
    this.newRecords.update((rows) => rows.map(preProcessRecordRow));

    function forEachRow(fn: (r: RowModificationRecipe) => void) {
      recipes.forEach(fn);
    }

    function forEachCell(fn: (cellKey: string) => void) {
      forEachRow((blueprint) =>
        blueprint.cells.forEach((cell) =>
          fn(getCellKey(blueprint.row.identifier, cell.columnId)),
        ),
      );
    }

    if (validateRecipes) {
      forEachRow((r) => validateRowModificationRecipe(r, pkColumn));
    }

    forEachCell((cellKey) => {
      cellStatus.set(cellKey, { state: 'processing' });
      this.updatePromises?.get(cellKey)?.cancel();
    });
    forEachRow(({ row }) => {
      if (isDraftRecordRow(row)) {
        rowCreationStatus.set(row.identifier, { state: 'processing' });
      }
      this.updatePromises?.get(row.identifier)?.cancel();
    });

    const requests = recipes.map(({ row, cells }) => {
      const recordDef = buildRecordFromRecipe(cells);
      if (isDraftRecordRow(row)) {
        return api.records.add({
          ...this.apiContext,
          record_def: {
            ...row.record,
            ...Object.fromEntries(this.contextualFilters),
            ...recordDef,
          },
        });
      }
      return api.records.patch({
        ...this.apiContext,
        record_id: row.record[pkColumn.id],
        record_def: recordDef,
      });
    });

    const responses = await batchSend(requests);
    const responseMap = new Map(
      execPipe(
        zip(recipes, responses),
        map(([blueprint, response]) => [
          blueprint.row.identifier,
          { blueprint, response },
        ]),
      ),
    );

    const cellsLoading = new Set(
      [...cellStatus.getEntries()]
        .filter(([, requestStatus]) => requestStatus.state === 'processing')
        .map(([cellId]) => cellId),
    );

    /**
     * This runs against **every row in the sheet** in order to do
     * post-processing, error handling, and UI updates based on the API
     * responses.
     *
     * @returns the `RecordRow` we want to persist on the front end going
     * forward
     */
    const postProcessRecordRow = <R extends RecordRow>(row: R): R => {
      const responseMapValue = responseMap.get(row.identifier);
      if (!responseMapValue) return row;
      const { blueprint, response } = responseMapValue;

      if (isDraftRecordRow(row)) {
        rowCreationStatus.delete(row.identifier);
      }

      /** Generate a row using the blueprint instead of the API return value */
      function makeFallbackRow() {
        const updatedValues = buildRecordFromRecipe(blueprint.cells);
        return row.withRecord({ ...row.record, ...updatedValues }) as R;
      }

      if (response.status === 'error') {
        // NOTE: this is a bit weird and could potentially be improved. If we
        // were unable to save the record we need to indicate to the user that
        // all target cells in the record have failed to update. The code
        // below is a rather crude way of doing this. If one cells caused the
        // whole record to fail, then the error message will be repeated for
        // each cell in the record. We could potentially improve on this by
        // using our `extractDetailedFieldBasedErrors` utility. But we'd still
        // need to figure how to show some kind of errors in other cells.
        blueprint.cells.forEach((cell) => {
          const cellKey = getCellKey(row.identifier, cell.columnId);
          cellStatus.set(cellKey, {
            state: 'failure',
            errors: [response],
          });
        });
        return makeFallbackRow();
      }
      const result = first(response.value.results);
      if (!result) return makeFallbackRow();

      const mergedResult = { ...row.record };
      for (const [columnId, newValue] of Object.entries(result)) {
        const cellId = makeCellId(row.identifier, columnId);
        const shouldStoreNewValue = (() => {
          // If the cell is part of the blueprint, then store the new value
          if (blueprint.cells.some((r) => r.columnId === columnId)) return true;

          // Ignore any _other_ loading cells. This is to handle the case where
          // a user is updating multiple cells in one record faster than the
          // network can respond. For example if the user updates cell A, then
          // updates B in the same row, and _then_ we receive the response for
          // cell A, we don't want to mutate cell B with the response from
          // update A because that would wipe out the optimistic UI updates that
          // we did at the start of operation B.
          if (cellsLoading.has(cellId)) return false;

          // Fall back to storing the new value. This case is necessary to store
          // newly-acquired PK values for provisional record rows being inserted
          // when editing cells.
          return true;
        })();
        if (shouldStoreNewValue) {
          mergedResult[columnId] = newValue;
        }
      }

      for (const columnId of Object.keys(row.record)) {
        const cellKey = getCellKey(row.identifier, columnId);
        cellStatus.set(cellKey, { state: 'success' });
        cellClientSideErrors.delete(cellKey);
      }

      if (isDraftRecordRow(row)) {
        return PersistedRecordRow.fromDraft(row.withRecord(mergedResult)) as R;
      }
      return row.withRecord(mergedResult) as R;
    };

    this.fetchedRecordRows.update((rows) => rows.map(postProcessRecordRow));
    this.newRecords.update((rows) => rows.map(postProcessRecordRow));

    this.updateSummaryStores(responses);
  }

  async refreshRow(rowId: string): Promise<void> {
    const row = get(this.selectableRowsMap).get(rowId);
    if (!row) return;
    if (!isPersistedRecordRow(row)) return;

    const { record } = row;
    const pkColumn = get(this.columnsDataStore.pkColumn);
    if (pkColumn === undefined) return;

    const primaryKeyValue = record[pkColumn.id];
    if (primaryKeyValue === undefined) return;

    const { joining } = get(this.meta.recordsRequestParamsData);

    const response = await api.records
      .get({
        ...this.apiContext,
        record_id: primaryKeyValue,
        return_record_summaries: this.loadIntrinsicRecordSummaries,
        ...joining.recordsRequestParams(),
      })
      .send();

    // We're silently swallowing errors. This might not be great for the user.
    // We could consider ways of displaying this, but it might require some
    // thought and design.
    if (response.status === 'error') return;
    const result = response.value;

    this.updateSummaryStores([{ status: 'ok', value: result }]);

    const updatedRecord = result.results[0];
    this.fetchedRecordRows.update((rows) =>
      rows.map((r) =>
        r.identifier === rowId ? r.withRecord(updatedRecord) : r,
      ),
    );
  }

  getEmptyApiRecord(): ApiRecord {
    const record: ApiRecord = Object.fromEntries(
      get(this.columnsDataStore.columns)
        .filter((column) => column.default === null)
        .map((column) => [String(column.id), null]),
    );
    return record;
  }

  private async createRecord(
    row: DraftRecordRow,
  ): Promise<DraftRecordRow | PersistedRecordRow> {
    const columns = get(this.columnsDataStore.columns);
    validateRow({
      row,
      columns,
      cellClientSideErrors: this.meta.cellClientSideErrors,
    });
    if (get(this.meta.rowsWithClientSideErrors).has(row.identifier)) {
      return row;
    }

    this.meta.rowCreationStatus.set(row.identifier, { state: 'processing' });
    this.createPromises?.get(row.identifier)?.cancel();

    const promise = api.records
      .add({
        ...this.apiContext,
        record_def: {
          ...Object.fromEntries(this.contextualFilters),
          ...row.record,
        },
      })
      .run();

    if (!this.createPromises) {
      this.createPromises = new Map();
    }
    this.createPromises.set(row.identifier, promise);

    try {
      const response = await promise;
      const record = response.results[0];
      const newRow = PersistedRecordRow.fromDraft(row.withRecord(record));

      this.meta.clearAllStatusesAndErrorsForRows([newRow.identifier]);
      this.meta.rowCreationStatus.set(newRow.identifier, { state: 'success' });
      this.newRecords.update((existing) =>
        existing.map((entry) => {
          if (entry.identifier === row.identifier) {
            return newRow;
          }
          return entry;
        }),
      );
      return newRow;
    } catch (err) {
      this.meta.rowCreationStatus.set(row.identifier, {
        state: 'failure',
        errors: [RpcError.fromAnything(err)],
      });
    } finally {
      if (this.createPromises.get(row.identifier) === promise) {
        this.createPromises.delete(row.identifier);
      }
    }
    return row;
  }

  async duplicateRecord(sourceRow: RecordRow): Promise<void> {
    const pkColumn = get(this.columnsDataStore.pkColumn);

    const fields = { ...sourceRow.record };
    if (pkColumn) {
      delete fields[pkColumn.id];
    }

    const newRow = new DraftRecordRow({
      record: {
        ...this.getEmptyApiRecord(),
        ...fields,
      },
    });

    this.newRecords.update((existing) => existing.concat(newRow));
    await this.createRecord(newRow);
  }

  async addEmptyRecord(): Promise<void> {
    const row = new DraftRecordRow({
      record: this.getEmptyApiRecord(),
    });
    this.newRecords.update((existing) => existing.concat(row));
    await this.createRecord(row);
  }

  getCellValue(cellSelectionId: string): ResultValue | undefined {
    const { columnId, rowId } = parseCellId(cellSelectionId);
    const rows = get(this.selectableRowsMap);
    const row = rows.get(rowId);
    if (!row) return undefined;
    return row.record[columnId];
  }

  destroy(): void {
    this.promise?.cancel();
    this.promise = undefined;

    this.requestParamsUnsubscriber();
  }
}
